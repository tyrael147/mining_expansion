/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-71.13422643665818, -12.04718705557845],
          [-71.13422643665818, -13.648465179143882],
          [-68.72822057728317, -13.648465179143882],
          [-68.72822057728317, -12.04718705557845]]], null, false),
    geometry2 = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-70.67505849956007, -13.133774724286214],
          [-69.84833730815382, -13.262128458096392],
          [-69.80164541362257, -12.64917546614451],
          [-70.56794180034132, -12.541956211238201],
          [-70.96344961284132, -12.957178860954686]]]),
    geometry3 = 
    /* color: #ffc82d */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.MultiPolygon(
        [[[[-70.88682838928372, -13.132912129340166],
           [-70.88682838928372, -13.234531425804297],
           [-70.55861183654935, -13.234531425804297],
           [-70.55861183654935, -13.132912129340166]]],
         [[[-69.68801973223367, -12.896971991199365],
           [-69.68801973223367, -12.9986884298005],
           [-69.50125215410867, -12.9986884298005],
           [-69.50125215410867, -12.896971991199365]]],
         [[[-70.55868623613992, -12.462878412773387],
           [-70.55868623613992, -12.613018999428691],
           [-70.0299691951243, -12.613018999428691],
           [-70.0299691951243, -12.462878412773387]]],
         [[[-69.6924176397636, -12.541329598170478],
           [-69.6924176397636, -12.811972102347022],
           [-69.44659854796673, -12.811972102347022],
           [-69.44659854796673, -12.541329598170478]]],
         [[[-69.4452252569511, -12.447475880087628],
           [-69.4452252569511, -12.66730791308818],
           [-69.2200055303886, -12.66730791308818],
           [-69.2200055303886, -12.447475880087628]]],
         [[[-69.1993087390294, -12.466337521825917],
           [-69.1993087390294, -12.555492857355835],
           [-69.1278976062169, -12.555492857355835],
           [-69.1278976062169, -12.466337521825917]]],
         [[[-69.03314052613878, -12.447564061141636],
           [-69.03314052613878, -12.50388036182402],
           [-68.96035610231066, -12.50388036182402],
           [-68.96035610231066, -12.447564061141636]]]], null, false),
    geometry4 = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-70.3181971653184, -12.90016340923899],
           [-70.29347792703715, -12.989835501467716],
           [-70.22344008524027, -12.984482850043893],
           [-70.18498793680277, -12.940319080233358],
           [-70.21108046609965, -12.892131500833374]]],
         [[[-70.07787123758402, -12.894808832278175],
           [-70.09023085672465, -12.941657491354524],
           [-70.03392592508402, -12.960394492363937],
           [-69.98723403055277, -12.949687807182876],
           [-69.9886073215684, -12.902840654743894]]],
         [[[-69.8952235325059, -13.076799888555037],
           [-69.92543593484965, -12.963071091731232],
           [-69.98174086649027, -12.969762464215016],
           [-70.04491225320902, -13.029976707304407]]],
         [[[-70.20696059305277, -13.141000080680376],
           [-70.20009413797465, -13.056733897291176],
           [-70.26738539774027, -13.050044871225705],
           [-70.27013197977152, -13.143674724846193]]],
         [[[-70.45277968484965, -12.999202363871326],
           [-70.50359145242777, -13.087501083318031],
           [-70.45415297586527, -13.114252036713683],
           [-70.40471449930277, -13.114252036713683],
           [-70.39372817117777, -13.0206110072808]]],
         [[[-70.61208144266215, -12.76224665771701],
           [-70.62993422586527, -12.823849889044135],
           [-70.4445399387559, -12.881421888753968],
           [-70.4060877903184, -12.814476454968302]]],
         [[[-70.30995741922465, -12.522387548890313],
           [-70.30034438211527, -12.680532283994747],
           [-70.22618666727152, -12.677852679237304],
           [-70.25502577859965, -12.504958870629796]]],
         [[[-70.52419081766215, -12.582708487335328],
           [-70.43080702859965, -12.714024962546205],
           [-70.37587538797465, -12.70062842051372],
           [-70.44865981180277, -12.550539079723988],
           [-70.52831069070902, -12.57332615942569]]],
         [[[-70.05589858133402, -12.545177120554278],
           [-70.1259364231309, -12.676512866286457],
           [-70.06413832742777, -12.695269605991129],
           [-70.02980605203715, -12.70062842051372],
           [-69.98448744852152, -12.5693050568332]]],
         [[[-69.47362319070902, -12.546517620816797],
           [-69.4283045871934, -12.691250420999445],
           [-69.33217421609965, -12.65239502878287],
           [-69.38161269266215, -12.531771734205224]]],
         [[[-69.78398696024027, -12.782336320017126],
           [-69.6919764621934, -12.76760405710958],
           [-69.71532240945902, -12.63363513476047],
           [-69.78398696024027, -12.640335255070363]]],
         [[[-69.56700697977152, -12.763586018204325],
           [-69.49834242899027, -12.74617377892086],
           [-69.55602065164652, -12.585389089477099],
           [-69.62468520242777, -12.614873863861346]]]]),
    geometry5 = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-70.99202366865948, -12.083564545279915],
          [-70.99202366865948, -13.349463607982605],
          [-68.86479588545636, -13.349463607982605],
          [-68.86479588545636, -12.083564545279915]]], null, false),
    geometry6 = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-70.6155593711229, -12.302067719416561],
          [-70.6155593711229, -13.247599819375974],
          [-69.06374052346665, -13.247599819375974],
          [-69.06374052346665, -12.302067719416561]]], null, false),
    geometry7 = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-70.9298385399701, -12.348210982418081],
          [-70.9298385399701, -13.250798890849618],
          [-68.8973678368451, -13.250798890849618],
          [-68.8973678368451, -12.348210982418081]]], null, false),
    geometry8 = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-70.64263547021447, -12.564852588691977],
          [-70.64263547021447, -13.116496615029746],
          [-69.54125607568324, -13.116496615029746],
          [-69.54125607568324, -12.564852588691977]]], null, false),
    geometry9 = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Point([-69.95793708993457, -12.90340547581532]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var roi = 
    /* color: #d63000 */
    /* shown: false */
    geometry2,
    vis_predicted = {"opacity":1,"bands":["classification"],"min":0,"max":1,"gamma":1},
    landform = ee.Image("CSP/ERGo/1_0/Global/SRTM_landforms"),
    data_pre = ee.Image("users/glarrea/data_pre_v4_100mpx"),
    all_mining = ee.FeatureCollection("users/glarrea/mining_article/Def_Min_SPA_1984_2017"),
    table = ee.FeatureCollection("users/glarrea/mining_article/data_180520_c"),
    point = 
    /* color: #ffc82d */
    /* shown: false */
    geometry9,
    image = ee.Image("OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02"),
    export_g = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    geometry5,
    geometry7 = 
    /* color: #98ff00 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    geometry8,
    geometry10 = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    geometry7,
    geometry = 
    /* color: #d63000 */
    /* shown: false */
    geometry4,
    data_analysis = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    geometry6,
    geometry2 = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPoint(),
    geometry9 = 
    /* color: #ffc82d */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      }
    ] */
    geometry3,
    geometry3 = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    geometry;


           
var min_proj = ee.Projection({crs:'EPSG:32719'}).atScale(30);
var landform = landform.select([0],['landform']); 
var clay = ee.Image("OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02");
var sand = ee.Image("OpenLandMap/SOL/SOL_SAND-WFRACTION_USDA-3A1A1A_M/v02");
var data_pre = ee.Image("users/glarrea/mining_article/data_pre_v5_150620");
var data_pre_hidro = ee.Image("users/glarrea/mining_article/data_pre_hidro");

clay = clay.select(["b200"],["clay"]);
sand = sand.select(["b200"],["sand"]); 

var limits = ee.FeatureCollection("users/glarrea/UntitledFolder/Perulimit"),
    carbon = ee.Image("users/glarrea/CarbonDensity"),
    srtm = ee.Image("USGS/SRTMGL1_003");
    
//// create maps/// 
var map1=ui.Map(), map2 =ui.Map();
var utils = require('users/glarrea/default:utils');
var db  = require('users/glarrea/default:database');
var fn = require('users/glarrea/mining:fn');
var hn = require('users/glarrea/default:hansen');
  
var slope = ee.Terrain.slope(srtm).clip(limits);
var coord = ee.Image.pixelLonLat();
var ROI = geometry10; //whole region of interest
var samplingArea = geometry7; //region of sampling 
// var samplingArea = ROI; //region of sampling, comment or uncomment to experiment with more geometries
var samplingScale = 100

var limitsgeo = limits.geometry(); 
var mining_kernel_2008_2017 = ee.ImageCollection(db.mining_kernel_2008_2017);
// Map.addLayer(mining_kernel_2008_2017.filter(ee.Filter.eq("year",2016)).first().reproject(min_proj));
var mining_database = all_mining;

///////////////////////////////util functions{
var get_miningYear = function(database, year, band_name){
  var miningYear = database.filter(ee.Filter.eq('Year',year)).reduceToImage({
                properties: ['Type'], 
                reducer:ee.Reducer.first()}).gte(1).unmask(0).select(['first'],[band_name]);
  return miningYear;
}; //Extracts the shapes for a given year from the database and returns a rasterized image


var sumNeighborhood = function (image) {
      var output = image.reduceNeighborhood({
          reducer:ee.Reducer.sum().unweighted(),
          kernel: ee.Kernel.circle(4,'pixels')
      });
      return output;
};

var addYear = function (image) {
    var index = image.get('system:index');  
    var number = ee.Number.parse(index).add(1);
    return image.addBands(number)
    .select(['mined_sum','constant'],['mined_sum','year'])
    .cast({'mined_sum': 'int64',
            'year': 'int64'
    }, ['mined_sum','year']);
};

var get_mining_coll = function(database, year, previousYears){
  var yearsList = ee.List.sequence(year - previousYears - 3 , year, 2).reverse();
  yearsList = yearsList.map(function(thisYear){
      var name = ee.String("mined");
      var miningYear = ee.Image(get_miningYear(mining_database, thisYear, name));
      return ee.Image(miningYear); 
  });
  return ee.ImageCollection(yearsList).toBands(); //creates a single image with bands combined
};
var get_mining_rate = function(database, year, previousYears){
  
  var yearsList = ee.List.sequence(year - previousYears - 3 , year - 2, 2);
  var minedCollection = yearsList.map(function(thisYear){  
      return get_miningYear(database, thisYear, "mined");
  });
  minedCollection = ee.ImageCollection(minedCollection); // We have to cast the list of images as ImageCollection
  return minedCollection.map(sumNeighborhood).map(addYear)  //this sums the mined neighboors and adds the corresponding year
        .select(["year", "mined_sum"]).reduce(ee.Reducer.linearFit()); // this applies a linear regression and stores the parameters as bands
  }; //returns the mining_rate image

var get_mining_neighbors = function(database, year, previousYears){
  
  var yearsList = ee.List.sequence(year - previousYears - 3, year- 2, 2).reverse();
  
  //maps a function to store the mined neighbors of each pixel for each previous year
  yearsList = yearsList.map(function(thisYear){ 
    
    var minedthisYear = get_miningYear(database, thisYear, "mined");  //the mined map for thisYear
    return sumNeighborhood(minedthisYear);
  });
  var minedNeighborsCol = ee.ImageCollection(yearsList).toBands(); // cast again as image as multiband image
  
  // creates a new list of names to replace the set of default names to avoid confusions
  var newNames = ee.List.sequence(1,previousYears, 1).map(function(number){return ee.String(ee.Number(number).toInt()).cat(ee.String("_neighbors"))});  
  return minedNeighborsCol.rename(newNames);
};

//}
 

/////////////Clustering{
// creates a cluster considering only the properties that are not changing in period of 1 year
var yearsTraining_initial = 2012;
var yearsTraining_final = 2016;
var mining_all = mining_database.filter(ee.Filter.gte('Year',yearsTraining_initial)).filter(ee.Filter.lte('Year',yearsTraining_final)).reduceToImage({
                properties: ['Type'], 
                reducer:ee.Reducer.first()}).gte(1).unmask(0).select(['first'],['mined']);         
var database_all = ee.Image.cat([data_pre,data_pre_hidro, mining_all, clay, sand]);

//using training dataset to cluster
var database_masked = database_all.updateMask(database_all.select(["mined"]));

var training_clustering = database_masked.stratifiedSample({ //This sampling selects only values = 1, discards null
    numPoints: 1000,
    classBand: 'mined',
    region: ROI,
    scale: 30,
    geometries: true});

var clusterer = ee.Clusterer.wekaXMeans({
  minClusters:2, 
  maxClusters:35, 
  maxIterations:4,
  seed:10
  }).train(training_clustering);
var clusters = database_masked.cluster(clusterer).add(1).unmask(0); //classifying and adding 1 to avoid class=0

var number_clusters = clusters.reduceRegion(    //obtains the number of clusters obtained from the X-means algorithm
  {reducer:ee.Reducer.minMax(),
  geometry:ROI,
  scale: 100
  }).getNumber("cluster_max").aside(print,"I am here");

Map.addLayer(clusters.randomVisualizer(),{},"here");
//}

/////////////Sampling {
//for each year

var outerBox = ROI.symmetricDifference(samplingArea, 100); // this outer box will be used to sample an additional test sample 
var outerBox = geometry9; // this outer box will be used to sample an additional test sample 
var innerBox = samplingArea;

var dataset_ImageCollection = ee.List([]); // empty list that will store dataset images for each year       
var dataset_training = ee.FeatureCollection([]); //empty FC that will store the training sampling data 
var dataset_training_2 = ee.FeatureCollection([]); //empty FC that will store the training sampling data 
var dataset_testing = ee.FeatureCollection([]); //empty FC that will store the testing sampling data 
var dataset_analysis = ee.FeatureCollection([]); //empty FC that will store the sampling data for analysis

var yearsTraining = [2011, 2013, 2015];
var yearsTesting = [2017];
var previousYears = 3;
var totalExamples = 3000;

//construct a database and sample from it for each year (training)
yearsTraining.forEach(function(year,index){
  
  //obtains the mined pixels for the present and previous years,
  var mining_coll = get_mining_coll(mining_database, year, previousYears);
  
  //obtains the mining rate for this year using former information
  var mining_rate = get_mining_rate(mining_database, year, previousYears);
  
  // obtains mined neighbors for each year 
  var miningNeighbors = get_mining_neighbors(mining_database, year, previousYears);
  
  //Pixels were designated as cluster 0 if they were not mined during that year
  // mining (0 or 1) can be used to transform not mined pixels to zero and to keep mined pixels with their cluster value.
  var clusters_corrected = mining_coll.select(["0_mined"]).multiply(clusters).rename(["cluster"]);
  
  //builds the database with static and dynamic variables 
  var database = ee.Image.cat([data_pre, data_pre_hidro, clay, sand, mining_coll, mining_rate, miningNeighbors, clusters_corrected]);  
  
  // Adds the database to the list containing databases for all years
  dataset_ImageCollection = dataset_ImageCollection.add(database.set({Year: year}));
  
  //Sampling 
  var not_mined = ee.Number(totalExamples); //number of not mined pixels,
  var mined = (not_mined.divide(number_clusters).round()); //dividing the not_mined to have a evenly distributed mined samples
  
  var classvalues =ee.List.sequence(0, number_clusters); // List of clusters (class 0: not mined, class 1: mined cluster 1, ... class: X, mined cluster X)
  var classpoints =ee.List([not_mined]).cat(ee.List.repeat(mined, number_clusters)); // List of sampled pixels per class

  var sample = database.stratifiedSample({
      numPoints: 10, //will be overriden
      // classBand: '0_mined',
      // classValues: [0,1],
      // classPoints: [totalExamples/2 ,totalExamples/2],
      classBand: 'cluster',           //uncomment to change the sampling criteria
      classValues: classvalues,
      classPoints: classpoints,
      region: innerBox,
      geometries:true,
      scale: samplingScale,
      projection: 'EPSG:32719'})
      .map(function(x){ 
            var y = x.set('year',year);
            return y;
    });

  dataset_training = dataset_training.merge(sample);
  
    var sample_2 = database.stratifiedSample({
      numPoints: 10, //will be overriden
      classBand: '0_mined',
      classValues: [0,1],
      classPoints: [totalExamples, totalExamples],
      // classBand: 'cluster',           //uncomment to change the sampling criteria
      // classValues: classvalues,
      // classPoints: classpoints,
      region: innerBox,
      geometries:true,
      scale: samplingScale,
      projection: 'EPSG:32719'})
      .map(function(x){ 
            var y = x.set('year',year);
            return y;
    });

  dataset_training_2 = dataset_training_2.merge(sample_2);
  
  
  
});

var copy_dataset_ImageCollection = dataset_ImageCollection

//construct a database and sample from it for each year (testing)
yearsTesting.forEach(function(year,index){
  
  //obtains the mined pixels for the present and previous years
  var mining_coll = get_mining_coll(mining_database, year, previousYears);
  
  //obtains the mining rate for this year using former information
  var mining_rate = get_mining_rate(mining_database, year, previousYears);
  
  // obtains mined neighbors for each year 
  var miningNeighbors = get_mining_neighbors(mining_database, year, previousYears);
  
  
  //Pixels were designated as cluster 0 if they were not mined during that year
  // mining (0 or 1) can be used to transform not mined pixels to zero and to keep mined pixels with their cluster value.
  var clusters_corrected = mining_coll.select(["0_mined"]).multiply(clusters);
  
  //builds the database with static and dynamic variables 
  var database = ee.Image.cat([data_pre, data_pre_hidro, clay, sand, mining_coll, mining_rate, miningNeighbors, clusters_corrected]);  //db.rate2012_mining, db.gold12, 
  
  // Adds the database to the list containing databases for all years
  dataset_ImageCollection = dataset_ImageCollection.add(database.set({Year: year}));
  
  // print(database.bandNames())
  var sample = database.stratifiedSample({
      numPoints: 10, //will be overriden
      classBand: '0_mined',
      classValues: [0,1],
      classPoints: [totalExamples/2 ,totalExamples/2],//we previosly selected only pixels equal to 12 (2012). The band name is changed to "lossyear"
      region: outerBox,
      geometries:true,
      scale: 30,
      projection: 'EPSG:32719'}).map(function(x){ 
    var y = x.set('year',year);
    return y;
  });

dataset_testing = dataset_testing.merge(sample);  
});

// cast the list as ImageCollection
dataset_ImageCollection = ee.ImageCollection(dataset_ImageCollection);
print(dataset_ImageCollection.first().bandNames(),"bandnames");
//}

/////////////EXPORTING{

// // Export.table.toDrive({
// //   collection: sample2013,
// //   description:'sample2013_lux',
// //   folder: 'mineria',
// //   fileFormat: 'CSV'
// // });
// // Export.table.toDrive({
// //   collection: sample2014,
// //   description:'sample2014_lux',
// //   folder: 'mineria',
// //   fileFormat: 'CSV'
// // });
// // Export.table.toDrive({
// //   collection: sample2015,
// //   description:'sample2015_lux',
// //   folder: 'mineria',
// //   fileFormat: 'CSV'
// // });
// // Export.table.toDrive({
// //   collection: sample2016,
// //   description:'sample2016_lux',
// //   folder: 'mineria',
// //   fileFormat: 'CSV'
// // });
// // var exmpl=sample2016.map(fn.getcoord);
// // Map.addLayer(sample2016.map(fn.getcoord));
// // print('samplecoords',exmpl);
// //}

/////////////Training{

// Partition the training.
var training_mixed = dataset_training; //keep changing
var training_mixed_2 = dataset_training_2; //keep changing
training_mixed = training_mixed.randomColumn({ seed: 10 });
training_mixed_2 = training_mixed_2.randomColumn({ seed: 10 });

var training = training_mixed.filter(ee.Filter.lt('random', 0.8));
var training_2 = training_mixed_2.filter(ee.Filter.lt('random', 0.8));
var validation =training_mixed.filter(ee.Filter.gte('random', 0.8));
var validation_2 =training_mixed_2.filter(ee.Filter.gte('random', 0.8));


// List of variables, comment or uncomment to select variables
var bands = [
  "distance_any",
  "distance_vec",
  "distance_dep",
  "distance_nac",
  "distance_buffer",
  "distance_parks",
  "distance_villages",
  "altitude",
  "slope",
  // "longitude",
  // "latitude",
  "landform",
  "distance_rivers",
  "distance_ponds",
  "clay",
  "sand",
  // "0_mined",
  // "1_mined", 
  // "2_mined",
  // "3_mined", 
  "scale",
  "offset",
  // "1_neighbors",
  // "2_neighbors",
  // "3_neighbors",
  // "cluster"   //this band is not using during training, delete it if preferable 
];

var classifier = ee.Classifier.smileRandomForest({
  numberOfTrees:  100, 
  bagFraction:0.2,
  minLeafPopulation:5, 
  maxNodes: 400,
  seed:1})
  .train({
  features: training,
  classProperty: '0_mined',
  inputProperties: bands
  })
// .setOutputMode('CLASSIFICATION')
.setOutputMode('PROBABILITY')
;  

var classifier_2 = ee.Classifier.smileRandomForest({
  numberOfTrees:  100, 
  bagFraction:0.2,
  minLeafPopulation:5, 
  maxNodes: 400,
  seed:1})
  .train({
  features: training_2,
  classProperty: '0_mined',
  inputProperties: bands
})
// .setOutputMode('CLASSIFICATION')
.setOutputMode('PROBABILITY')
; 

print(classifier.explain());

// var trainAccuracy = classifier.setOutputMode('CLASSIFICATION').confusionMatrix().accuracy(); // not valid for probability
// print('confusion',classifier.setOutputMode('CLASSIFICATION').confusionMatrix());
// print('trainAccuracy', trainAccuracy);

// var testAccuracy = validation
var testAccuracy = dataset_testing
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification')
    .accuracy();
print('testAccuracy', testAccuracy);                 //only for classification
// print(validation
print(dataset_testing
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification'));


print('testAccuracy classifier 1: inside sample',validation
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification')
    .accuracy());                 //only for classification
print(validation
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification'));

print('testAccuracy classifier 1: outside sample', dataset_testing
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification')
    .accuracy());                 //only for classification
print(dataset_testing
    .classify(classifier.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification'));

print('testAccuracy classifier 2: inside sample',validation_2
    .classify(classifier_2.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification')
    .accuracy());                 //only for classification
print(validation_2
    .classify(classifier_2.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification'));

print('testAccuracy classifier 2: outside sample', dataset_testing
    .classify(classifier_2.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification')
    .accuracy());   
print(dataset_testing
    .classify(classifier_2.setOutputMode('CLASSIFICATION'))
    .errorMatrix('0_mined', 'classification'));
//}

/////////////Predicting{

var mined_11_16 = all_mining.filter(ee.Filter.gte('Year',2000)).filter(ee.Filter.lte('Year',2016)).reduceToImage({
                properties: ['Type'], 
                reducer:ee.Reducer.first()}).gte(1).unmask(0).select(['first'],['0_mined']);     
                
var mined_2011 = dataset_ImageCollection.filterMetadata("Year","equals",2011).first().select(["0_mined"])
var mined_2013 = dataset_ImageCollection.filterMetadata("Year","equals",2013).first().select(["0_mined"])
var mined_2015 = dataset_ImageCollection.filterMetadata("Year","equals",2015).first().select(["0_mined"])



var database_2017 = ee.Image(dataset_ImageCollection.filterMetadata("Year","equals",2017).first());
var predicted_2017 = database_2017.select(bands).classify(classifier.setOutputMode('CLASSIFICATION'));
var prev_mined_2017 = mined_2011.add(mined_2013).add(mined_2015)
var mined_2017 = predicted_2017.subtract(mined_11_16.gte(1)).rename(['0_mined'])

Map.addLayer(mined_2017,{min:0, max:1}, 'mined_2017')

// copy_dataset_ImageCollection = ee.List(dataset_ImageCollection.filterMetadata('Year', 'equals', 2017)).aside(print)

// // Creating 2019 db
// var year = 2019
// var iC2019 = ee.ImageCollection([mined_2013, mined_2015, mined_2017])
// var mining_rate_2019 = iC2019.map(sumNeighborhood).map(addYear)  //this sums the mined neighboors and adds the corresponding year
//         .select(["year", "mined_sum"]).reduce(ee.Reducer.linearFit()); // this applies a linear regression and stores the parameters as bands
// var mining_neigh_2019 = iC2019.map(function(thisYear){ 
//     return sumNeighborhood(thisYear);
//   });
// mining_neigh_2019 = ee.ImageCollection(mining_neigh_2019).toBands(); // cast again as image as multiband image
//   // creates a new list of names to replace the set of default names to avoid confusions
// var newNames = ee.List.sequence(1,previousYears, 1).map(function(number){return ee.String(ee.Number(number).toInt()).cat(ee.String("_neighbors"))});  
// mining_neigh_2019 = mining_neigh_2019.rename(newNames);


//}

/////////////Visualizing {
var class_vis = {palette:['#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac'].reverse(),
              max: 1, min:0};
var database_2017 = ee.Image(dataset_ImageCollection.filterMetadata("Year","equals",2017).first());
// Map.addLayer(database_2017, {}, "database_2017");
Map.addLayer(database_2017.select(bands).classify(classifier).reproject(min_proj), class_vis, "predicted_2017");
Map.addLayer(database_2017.select(bands).classify(classifier.setOutputMode('CLASSIFICATION')).reproject(min_proj), class_vis, "predicted_2017_CLASS");
// Map.addLayer(database_2017.select(bands).classify(classifier.setOutputMode('CLASSIFICATION')).reproject(min_proj), class_vis, "predicted_2017_bin");
// Map.addLayer(mining_database.filterMetadata("Year","equals", 2017),{},"real_2017");
// Map.addLayer(mining_database.filterMetadata("Year","equals", 2016),{},"real_2016");
// Map.addLayer(mining_database.filterMetadata("Year","greater_than", 2008),{color:"green"},"real_2008up");
// Map.addLayer(dataset_training)
// Map.addLayer(outerBox,{},"outerBox")
//}

/////////Exporting{
  
Export.image.toAsset({
  image:database_2017.select(bands).classify(classifier.setOutputMode('PROBABILITY')), 
  description:'temporal_2017_small_2', 
  assetId:'mining_article/rasters_new/temporal_2017_small_2', 
  region: geometry3, 
  scale:100, 
  crs: 'EPSG:32719',
  maxPixels:1e13
  });
  
  
//Export CSV{

// Export.table.toDrive({ 
//   collection: validation.classify(classifier.setOutputMode('PROBABILITY')),
//   description:'small_in_clust_shortterm',
//   folder: 'mineria', 
//   fileFormat: 'CSV'
// });
// Export.table.toDrive({
//   collection: validation_2.classify(classifier_2.setOutputMode('PROBABILITY')),
//   description:'small_in_strata_shortterm',
//   folder: 'mineria', 
//   fileFormat: 'CSV'
// });
// Export.table.toDrive({ 
//   collection: dataset_testing.classify(classifier.setOutputMode('PROBABILITY')),
//   description:'small_out_clust_shortterm',
//   folder: 'mineria', 
//   fileFormat: 'CSV'
// });
// Export.table.toDrive({
//   collection: dataset_testing.classify(classifier_2.setOutputMode('PROBABILITY')),
//   description:'small_out_strata_shortterm',
//   folder: 'mineria', 
//   fileFormat: 'CSV'
// });

Export.table.toDrive({ //uncomment only when ROI has been selected as sampling area 
  collection: validation.classify(classifier.setOutputMode('PROBABILITY')),
  description:'big_in_clust_shortterm',
  folder: 'mineria', 
  fileFormat: 'CSV'
});
Export.table.toDrive({
  collection: validation_2.classify(classifier_2.setOutputMode('PROBABILITY')),
  description:'big_out_strata_shortterm',
  folder: 'mineria', 
  fileFormat: 'CSV'
});



//}

//Export image{
  
  
// }



// var pred_2017 = database_2017.select(bands).classify(classifier)
// var mined_2015 = get_miningYear(all_mining, 2015, "mined")
// var mined_2014 = get_miningYear(all_mining, 2014, "mined")
// var mined_2013 = get_miningYear(all_mining, 2013, "mined")
// var mined_2012 = get_miningYear(all_mining, 2012, "mined")
// var mined_2011 = get_miningYear(all_mining, 2011, "mined")
// var mined_2010 = get_miningYear(all_mining, 2010, "mined")

// var new_2017 = pred_2017.updateMask(mined_2015.eq(0)).updateMask(mined_2014.eq(0)).updateMask(mined_2013.eq(0)).updateMask(mined_2012.eq(0)).updateMask(mined_2011.eq(0))

// Map.addLayer(new_2017, class_vis, "predicted_2017");